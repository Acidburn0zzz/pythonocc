#!/usr/bin/scons
# coding: UTF-8

##Copyright 2008-2009 Thomas Paviot (thomas.paviot@free.fr)
##
##This file is part of pythonOCC.
##
##pythonOCC is free software: you can redistribute it and/or modify
##it under the terms of the GNU General Public License as published by
##the Free Software Foundation, either version 3 of the License, or
##(at your option) any later version.
##
##pythonOCC is distributed in the hope that it will be useful,
##but WITHOUT ANY WARRANTY; without even the implied warranty of
##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##GNU General Public License for more details.
##
##You should have received a copy of the GNU General Public License
##along with pythonOCC.  If not, see <http://www.gnu.org/licenses/>.

from distutils import sysconfig, msvccompiler
import os
import sys
import commands
import SCons
import platform
from Modules import MODULES

##########################################################################################
########## PROXY TO NEWER SCONS (DOWNLOADED IF NEEDED) ###################################
##########################################################################################
# SCons version numbers are needed a few times
ver=[str(x) for x in SCons.__version__.split('.')]
for i in range(0,len(ver)):
	def any2num(x):
		if x in ('0123456789'): return x
		else: return '0'
	ver[i]="".join([any2num(x) for x in ver[i]])
	if len(ver[i])>2: ver[i]=ver[i][0:2]+"."+ver[i][2:]
sconsVersion=10000*float(ver[0])
if len(ver)>1: sconsVersion+=100*float(ver[1])
if len(ver)>2: sconsVersion+=float(ver[2])

if sconsVersion<9806.0 and not os.environ.has_key('NO_SCONS_GET_RECENT'):
	tgzParams=("http://heanet.dl.sourceforge.net/sourceforge/scons/scons-local-1.0.0.tar.gz","/scons-local-1.0.0")
	newPrefix="./scons-local";
	newUrl,newDir=tgzParams[0],newPrefix+"/"+tgzParams[1]
	if not os.path.exists(newDir):
		print "Scons version too old, downloading new version. All subsequent calls will be proxied to the new version transparently."
		import urllib,tarfile
		(filename,headers)=urllib.urlretrieve(newUrl)
		print filename,"\n",headers
		tar=tarfile.open(filename, "r:gz")
		for tarinfo in tar: tar.extract(tarinfo,newPrefix)
		print "Done extracting scons to",newDir
		assert(os.path.exists(newDir))
	if os.path.exists(newDir):
		Exit(os.execv(newPrefix+"/scons.py",[newPrefix+'/scons.py']+sys.argv[1:]))
#
# Create environment
#
env = Environment()
BUILD_ROOT = os.path.join(os.getcwd(),'..','build')
BUILD_DIR = os.path.join(BUILD_ROOT,'OCC')
if not os.path.isdir(BUILD_ROOT):
        os.mkdir(BUILD_ROOT)
if not os.path.isdir(BUILD_DIR):
        os.mkdir(BUILD_DIR)        
BuildDir(BUILD_DIR,'.',duplicate = 0)
#
# First define platform specific settings
#
#
# Define pythonOCC version
#
VERSION = 'wo0.2'
#
# Define paths
#
try:
    OCC_ROOT = os.environ['CASROOT']
except KeyError:
    print "OpenCascade CAS_ROOT environment variable not set."
    OCC_ROOT = None

if sys.platform=='win32':
    SWIG_FILES_PATH_MODULAR = os.path.join(os.getcwd(),'SWIG_src_modular_win32')
    # Try to find OCC paths from environment analysis
    if OCC_ROOT!=None:
        OCC_INC = os.path.join(OCC_ROOT,'inc')
        OCC_LIB = os.path.join(OCC_ROOT,'win32','lib')
    GCC_XML_PATH = os.path.join(os.getcwd(),'pygccxml','gccxml_bin','v09','win32','bin')
    PYGCCXML_DEFINES = ['WNT','__SWIG_GENERATION__','CSFDB','WIN32','_WINDOWS']
    DEFINE_MACROS = ['WNT','WIN32','_WINDOWS','CSFDB','NDEBUG']
    ECA = ['/Ox','/MD','/W3','/GX','/link']
    SWIG_OPTS = ['-O','-python','-c++','-DWNT','-Wall','-DCSFDB','-DWIN32','-D_WINDOWS','-outdir',BUILD_DIR]
    ELA = []
    EXTRA_LIBS = []    
elif sys.platform=='linux2':
    architecture = platform.machine() #returns i386, i686 etc.
    SWIG_FILES_PATH_MODULAR = os.path.join(os.getcwd(),'SWIG_src_modular_linux_darwin')
    OCC_INC = '/usr/local/inc' # Ubuntu 8.04 Hardy default installation path for headers
    CONFIG_H_PATH = '/usr/local/inc'
    OCC_LIB = '/usr/local/lib' # Ubuntu 8.04 Hardy default installation path for libraries
    GCC_XML_PATH = '/usr/bin' # Ubuntu 8.04 Hardy installation path for gccxml
    PYGCCXML_DEFINES = ['HAVE_CONFIG_H','HAVE_LIMITS_H','CSFDB','OCC_CONVERT_SIGNALS','LIN','LININTEL','_GNU_SOURCE=1']
    DEFINE_MACROS = ['HAVE_CONFIG_H','HAVE_LIMITS_H','CSFDB','OCC_CONVERT_SIGNALS','LIN','LININTEL',('_GNU_SOURCE','1')]
    SWIG_OPTS = ['-python','-modern','-fcompact','-c++','-DHAVE_LIMITS_H','-DHAVE_CONFIG_H','-DCSFDB',\
                 '-DOCC_CONVERT_SIGNALS','-DLIN','-DLININTEL','-D_GNU_SOURCE=1'],#'-outdir',BUILD_DIR]
    ECA = ['-O0','-march=%s'%architecture]
    lib_python = sysconfig.get_config_var('BLDLIBRARY').split(' ')[1]
    ELA = ['-Wl,--no-undefined']
    EXTRA_LIBS = ['m','stc++',lib_python]
elif sys.platform=='darwin':
    SWIG_FILES_PATH_MODULAR = os.path.join(os.getcwd(),'SWIG_src_modular_linux_darwin')
    architecture = platform.machine()
    OCC_INC = '/usr/local/inc'
    OCC_LIB = '/usr/local/lib'
    GCC_XML_PATH = '/usr/bin' 
    PYGCCXML_DEFINES = ['HAVE_CONFIG_H','HAVE_LIMITS_H','CSFDB','OCC_CONVERT_SIGNALS']
    DEFINE_MACROS = [('HAVE_CONFIG_H',None),('HAVE_LIMITS_H',None),('CSFDB',None),('OCC_CONVERT_SIGNALS',None)]
    SWIG_OPTS = ['-python','-modern','-fcompact','-c++','-DHAVE_LIMITS_H','-DHAVE_CONFIG_H','-DCSFDB',\
                 '-DOCC_CONVERT_SIGNALS'],#'-outdir',BUILD_DIR]
    ECA = ['-O0','-march=%s'%architecture]
    lib_python = sysconfig.get_config_var('BLDLIBRARY').split(' ')[1]
    ELA = ['-Wl,--no-undefined']
    EXTRA_LIBS = ['m','stc++',lib_python]
else:
    raise "Unsupported platform"
#
# Set Win32 paths
#
if env['PLATFORM']=='win32':
	env['ENV']['PATH']=os.environ['PATH'].split(';')
	includes = os.environ['INCLUDE'].split(';')
	env.Append(CPPPATH=os.environ['INCLUDE'].split(';'))
	env.Append(LIBPATH=os.environ['LIB'].split(';'))
	env['ENV']['TMP'] = os.environ['TMP']
#
# Build Options
#
#opts=Variables()
#opts.AddVariables(
#('OCC_INC','Directories where to look for OpenCascade headers',['/usr/inc','/usr/local/inc','./inc',OCC_INC],None,Split),
#)
#opts.Update(env)

print 'Build pythonOCC-%s for platform: %s'%(VERSION,platform.platform())

env.Append(CXXFLAGS=ECA)
env.Append(CPPDEFINES=DEFINE_MACROS)	
env.Append(LINKFLAGS=ELA)
#
# Setting paths
#
PYTHON_INC = sysconfig.get_python_inc()
PYTHON_LIB = sysconfig.get_python_lib()
VISUALIZATNION_PATH = os.path.join(os.getcwd(),SWIG_FILES_PATH_MODULAR,'Visualization')
MISC_PATH = os.path.join(os.getcwd(),SWIG_FILES_PATH_MODULAR,'Misc')
env.Append( CPPPATH= [PYTHON_INC,OCC_INC, VISUALIZATION_PATH, MISC_PATH])
env.Append( LIBPATH = [OCC_LIB] )
env.Append( LIBPATH = PYTHON_LIB)
if env['PLATFORM']!='win32':
    env.Append( CPPPATH= [CONFIG_H_PATH])
#
# Check configuration
#
def CheckPygccxml(context):
	context.Message('Checking for pygccxml ...')
	if env.Detect('gccxml') == None:
		context.Result(False)
		GCCXML = False
	else:
		context.Result(True)
		GCCXML = False
		return True
		
def CheckSwig(context):
	context.Message('Checking for swig ...')
	if env.Detect('swig') == None:
		context.Result(False)
		Exit(1)
	else:
		context.Result(True)
		return True

def CheckCXX(context):
	context.Message('Checking whether c++ compiler "%s" works...'%env['CC'])
	ret=context.TryLink('#include<iostream>\nint main(int argc, char**argv){std::cerr<<std::endl;return 0;}\n','.cpp')
	context.Result(ret)
	return ret
	
def CheckOCC(context):
	occdirs = env['OCC_INC']
	print occdirs
	for occdir in occdirs:
		context.Message( 'Checking for OpenCascade headers in '+occdir+'... ' )
		context.env['OCC_INC']=occdir
		ret=context.TryLink('/**/','.cpp')##include<Standard.hxx>;\n','.cpp')
		context.Result(ret)
		if not ret:
			print "OCC does not work."
		else:
			return ret
	return False	

conf = env.Configure(custom_tests={'CheckCXX':CheckCXX,'CheckSwig':CheckSwig,'CheckOCC':CheckOCC},)

conf.CheckCXX()
conf.CheckSwig()
#conf.CheckOCC() don't work
if not conf.CheckCXXHeader('stdlib.h','<>'):
	Exit(1)
if not conf.CheckCXXHeader('string.h','<>'):
	Exit(1)
if not conf.CheckCXXHeader('Python.h','<>'):
	Exit(1)
if not conf.CheckCXXHeader('stdexcept','<>'):
	Exit(1)
if env['PLATFORM']=='posix':
	if not conf.CheckCXXHeader('X11/XWDFile.h','<>'):
		Exit(1)
	if not conf.CheckCXXHeader('cstdlib','<>'):
		Exit(1)
#
# Check available OpenCascade libs on dest machine
# The ALL_ACC_LIBRARIES list is generated from the Windows distribution
# of OpenCascade6.3.0
#
ALL_OCC_LIBRARIES = ['BinLPlugin', 'BinPlugin', 'BinXCAFPlugin', 'FWOSPlugin', 'mscmd', 'PTKernel',\
             'StdLPlugin', 'StdPlugin', 'TKAdvTools', 'TKBin', 'TKBinL', 'TKBinTObj', 'TKBinXCAF',\
             'TKBO', 'TKBool', 'TKBRep', 'TKCAF', 'TKCDF', 'TKCDLFront', 'TKCPPClient', 'TKCPPExt',\
             'TKCPPIntExt', 'TKCPPJini', 'TKCSFDBSchema', 'TKDCAF', 'TKDraw', 'TKernel',\
             'TKFeat', 'TKFillet', 'TKG2d', 'TKG3d', 'TKGeomAlgo', 'TKGeomBase', 'TKHLR', 'TKIDLFront',\
             'TKIGES', 'TKjcas','TKLCAF', 'TKMath', 'TKMesh', 'TKMeshVS', 'TKNIS', 'TKOffset',\
             'TKOpenGl', 'TKPCAF', 'TKPLCAF', 'TKPrim', 'TKPShape', 'TKService', 'TKShapeSchema',\
             'TKShHealing', 'TKStdLSchema', 'TKStdSchema', 'TKSTEP', 'TKSTEP209', 'TKSTEPAttr',\
             'TKSTEPBase', 'TKSTL', 'TKTCPPExt', 'TKTObj', 'TKTObjDRAW', 'TKTopAlgo', 'TKTopTest',\
             'TKV2d', 'TKV3d', 'TKViewerTest', 'TKVRML', 'TKWOK', 'TKWOKTcl', 'TKXCAF', 'TKXCAFSchema',\
             'TKXDEDRAW', 'TKXDEIGES', 'TKXDESTEP', 'TKXMesh', 'TKXml', 'TKXmlL', 'TKXmlTObj',\
             'TKXmlXCAF', 'TKXSBase', 'TKXSDRAW','XCAFPlugin', 'XmlLPlugin', 'XmlPlugin',\
             'XmlXCAFPlugin']
AVAILABLE_OCC_LIBS = []
for lib in ALL_OCC_LIBRARIES:
	if conf.CheckLib(lib, language = "C++"):
		AVAILABLE_OCC_LIBS.append(lib)
#
# Check extra libs
#
AVAILABLE_EXTRA_LIBS = []
for extra_lib in EXTRA_LIBS:
	if conf.CheckLib(extra_lib, language = "C++"):
		AVAILABLE_EXTRA_LIBS.append(extra_lib)
#
# End Configuration check
#
env = conf.Finish()
#
# SConscript
#
#buildDir=os.path.join(os.getcwd(),'build_scons')
#env.SConscript(dirs=['.'],build_dir=buildDir,duplicate=0)
#SConscript('SConscript', build_dir=buildDir, duplicate=0, exports={'MODE':'release'})

##################################
#### Create __init__.py script ###
##################################
def Create__init__():
    """
    Create the __init__.py file for OCC package.
    just create domething like: __all__ = ['gp,'gce']
    """
    print "Creating __init__.py script."
    init_fp = open(os.path.join(BUILD_DIR,'__init__.py'),'w')
    #
    # First set important OpenCascade env var
    # These settings are taken from OCC message forum:
    # http://www.opencascade.org/org/forum/thread_12800/
    # I did a test case in my OCAF application, and i could not see any problem, even with your first case.My environment variables concerning the memory manager are:
    #
    #MMGT_OPT=1 //use the optimised memory manager
    #MMGT_CLEAR=1 //this is important , at least in my case.Many problems could rise if i did not set this variable.Sets all bits of new allocated memory to NULL.
    #MMGT_REENTRANT=0 //My application is not multi threaded , so i do not need this.
    init_fp.write('import os\n')
    init_fp.write('#\n#Define OpenCascade behaviour settings\n#\n')
    init_fp.write("os.environ['MMGT_CLEAR']='1'\n")
    init_fp.write("os.environ['MMGT_OPT']='1'\n")
    init_fp.write("os.environ['MMGT_REENTRANT']='0'\n")
    init_fp.write("os.environ['CSF_EXCEPTION_PROMPT']='1'\n")
    # Display stuff
    init_fp.write("os.environ['DISPLAY']=':0.0'\n")
    init_fp.write("os.environ['CSF_GraphicShr']='/usr/local/lib/libTKOpenGL.so'\n")
    #
    # Include Version number
    #
    init_fp.write("VERSION='%s'\n"%VERSION)
    #
    init_fp.write('__all__=[')
    for module_tuple in MODULES:
        module_name = module_tuple[0]
        init_fp.write("'%s',\n"%module_name)
    init_fp.write("'Visualization',\n'Misc'\n")
    init_fp.write(']\n')
    init_fp.close()
Create__init__()
##############################
#### pythonOCC build #########
##############################
#
# First generate the SWIG .i files if they're not in the SWIG_* path
#
for module in MODULES:
	module_name = module[0]
	SWIG_source_file = os.path.join(os.getcwd(),SWIG_FILES_PATH_MODULAR,"%s.i"%module_name)
	if not (os.path.isfile(SWIG_source_file)): #if no .i file, generate_it		
		import SWIG_generator
		builder = SWIG_generator.ModularBuilder(module, False)
#
# SWIGing .i files
#
env['SWIGFLAGS'] = [SWIG_OPTS]
env['SWIGPATH']  = [OCC_INC]
env['LIBS']=AVAILABLE_OCC_LIBS + AVAILABLE_EXTRA_LIBS
#
# Build shared libraries
#
for module in MODULES:
	module_name = module[0]
	SWIG_source_file = os.path.join(os.getcwd(),SWIG_FILES_PATH_MODULAR,"%s.i"%module_name)
	SHARED_Library_pathname = os.path.join(BUILD_DIR,'%s'%module_name)
	env.SharedLibrary(SHARED_Library_pathname, [SWIG_source_file],SHLIBPREFIX = '_', SHLIBSUFFIX = sysconfig.get_config_vars()['SO'])
# Build Visualization
SWIG_source_file = os.path.join(VISUALIZATION_PATH,'Visualization.i')
CC1 = os.path.join(VISUALIZATION_PATH,'Display2d.cpp')
CC2 = os.path.join(VISUALIZATION_PATH,'Display3d.cpp')
CC3 = os.path.join(VISUALIZATION_PATH,'NISDisplay3d.cpp')
SHARED_Library_pathname = os.path.join(BUILD_DIR,'Visualization')
env.SharedLibrary(SHARED_Library_pathname, [SWIG_source_file, CC1, CC2, CC3],SHLIBPREFIX = '_', SHLIBSUFFIX = sysconfig.get_config_vars()['SO'])
# Build Misc
SWIG_source_file = os.path.join(MISC_PATH,'Misc.i')
SHARED_Library_pathname = os.path.join(BUILD_DIR,'Misc')
env.SharedLibrary(SHARED_Library_pathname, [SWIG_source_file],SHLIBPREFIX = '_', SHLIBSUFFIX = sysconfig.get_config_vars()['SO'])
